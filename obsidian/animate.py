from dataclasses import dataclass, fields
from drawSvg import animate_video, animate_jupyter
import re

from copy import copy
from canvas import render
from fields import STYLE
from groups import Group
from lerps import lerp_colors


"""
Supports both frame-by-frame and keyframed animation styles.

Keyframe engine is still WIP and is being built out on an as-needed basis.

---

OK, so here's the idea. We generate one Group per keyframe (or frame).
These groups all have *completely different Shape instances* in them.
They might be generated by a frame factory function (or maybe just passed in?)

    nice thing about a factory is we can make "working copies" of a Group,
    rather than being responsible for an externally-visible Group (that we then
    couldn't modify, because that would constitute a side effect)

The way we associate shapes in one keyframe w/ the same shapes in the next
keyframe (where they'll be different instances w/ possibly different positions,
sizes, and styles) is by *name*

If the animation engine sees the same named shape in two keyframes, it'll fill
in the intermediate frames by lerping position, color, and other parameters as
needed.

It'll do this by passing in raw values for int/float/etc params, lerped from the
solved numeric values for the keyframes' shapes' params.

    Let's start by just lerping color for now; that'll be easy to debug and once
    we get that working it'll be easy enough to add lerps for other params too
    (ultimately we should lerp style fields + all free variables + probably also
    any params defined as numeric literals)
"""


@dataclass
class Keyframe:
    frame_num: int
    frame: Group


class KeyframeAnimation:
    def __init__(self, draw_func, framerate):
        self.draw_func = draw_func  # must return a Group, NOT a Canvas or Drawing!!
        self.framerate = framerate
        self._frame_num = 0
        self._keyframes = []

    def add_keyframe(self, delta, *args, **kwargs):
        """Adds a new keyframe at +delta frames from the last keyframe.
        For the first keyframe, set delta=0."""

        group = self.draw_func(*args, **kwargs)
        self._frame_num += delta
        self._keyframes.append((self._frame_num, group))

    # all 3 of these render functions accept args & kwargs and pass them on
    # to the render() function, which passes them to the render Canvas

    def render_jupyter(self, *args, **kwargs):
        assert len(self._keyframes) > 0
        with animate_jupyter() as anim:
            self._render(anim, *args, **kwargs)

    def render_file(self, fname, *args, **kwargs):
        assert len(self._keyframes) > 0
        last_keyframe = self._keyframes[-1]
        duration = last_keyframe.frame_num / self.framerate
        with animate_video(fname, duration) as anim:
            self._render(anim, *args, **kwargs)

    def _render(self, anim, *args, **kwargs):
        """..."""

        # loop over pairs of keyframes
        # for each pair, draw the first one, then draw the frames between them
        # (the final one needs to be drawn after the loop)

        for group in self._get_groups():
            frame = render(group, *args, **kwargs)
            anim.append_frame(frame)

    def _get_groups(self):
        for cur, nxt in zip(self._keyframes, self._keyframes[1:]):
            cur_num, cur_group = cur
            nxt_num, nxt_group = nxt

            yield cur_group
            yield from self._interpolate(cur, nxt, nxt_num-cur_num)
        yield nxt_group

    def _interpolate(self, cur: Group, nxt: Group, steps: int):
        """Interpolates from `cur` to `nxt` in `steps` steps, but yields *only*
        the intermediate, interpolated groups, skipping both endpoints. As such,
        the iterator will yield a total of `steps-1` times.
        """

        style_originals = {}
        style_lerps = {name: {} for name in cur.keys()}

        # precompute the lerps for each frame
        for name, cur_shape in cur.items():
            assert name in nxt  # or should we just silently continue?
            nxt_shape = nxt[name]
            assert hasattr(cur_shape, 'style')
            assert hasattr(nxt_shape, 'style')

            style_originals[name] = cur_shape.style  # back up the style dict
            cur_shape.style = copy(cur_shape.style)  # (temporarily) replace style dict with shallow copy

            for prop in _get_color_styles(cur_shape.style):
                assert prop in nxt_shape.styles  # or just continue?
                c1 = cur_shape.styles[prop]
                c2 = nxt_shape.styles[prop]
                interp = lerp_colors(c1, c2, steps)
                style_lerps[name][prop] = interp[1:-1]  # trim the endpoints

        # NOTE: we've only shallow-copied the style dicts, so we should only
        # make shallow changes to it - this shouldn't be a problem, but it might
        # be nonobvious to the reader, and failing to follow this guidance could
        # lead to truly maddening side-effects and bugs, so just thought I'd
        # leave a note to this effect for any future developers :)

        # generate the frames
        for i in range(steps-1):
            for name, styles in style_lerps.items():  # NOTE: could precompute
                for key, vals in styles.items():      # these for performance
                    val = vals[i]
                    cur[name].style[key] = val
            yield cur  # sssh, don't tell the caller we're giving them the same
                       # group over and over :)

        # replace the copied styles with their originals
        # it's gonna suuuuuuuuuuuuuuuuuuuuuuuuuck having to do this for coords
        for name, original_style in style_originals:
            cur[name] = original_style


_color_regex = re.compile(r"#[0123456789abcdefABCDEF]{6}")
def _get_color_styles(style):
    """Returns a tuple of keys from 'style' whose values look like hex
    colors."""

    return tuple(key for key, val in style if _color_regex.fullmatch(val))
